// Advanced Programming, A. Wąsowski, IT University of Copenhagen
//
// Group number: 25
//
// AUTHOR1: André Kobæk
// akob@itu.dk
// TIME1: 8 hours <- how much time have you used on solving this exercise set
// (excluding reading the book, fetching pizza, and going out for a smoke)
//
// AUTHOR2: Hugo Brito
// hubr@itu.dk
// TIME2: 8 <- how much time have you used on solving this exercise set
// (excluding reading the book, fetching pizza, and going out for a smoke)
//
// AUTHOR2: Jonas Hartmann Andersen
// haja@itu.dk
// TIME3: 2.5 <- how much time have you used on solving this exercise set
// (excluding reading the book, fetching pizza, and going out for a smoke)
//
// You should work with the file by following the associated exercise sheet
// (available in PDF from the course website).
//
// The file shall always compile and run after you are done with each exercise
// (if you do them in order).  Please compile and test frequently. Of course,
// some tests will be failing until you finish. Only hand in a solution that
// compiles and where tests pass for all parts that you finished.    The tests
// will fail for unfnished parts.  Comment such out.
//
// Before starting to work on the exercises, familiarize yourself with the the
// content already in the file (it has been explained in chapter 8, but it is
// useful to see it all together in one file).

package adpro.testing
import fpinscala.state._
import fpinscala.state.RNG._

// A generator will use a random number generator RNG in its state, to create
// random instances (but perhaps also some other staff)
case class Gen[A] (sample :State[RNG,A]) {

	// Let's convert generator to streams of generators
	def toStream (seed: Long): Stream[A] =
		Gen.state2stream (this.sample) (RNG.Simple (seed))
	def toStream (rng: RNG): Stream[A] =
		Gen.state2stream (this.sample) (rng)

	// Exercise 3
	// Implement a method Gen[A].listOfN, which given an integer number n returns
	// a list of length n containing A elements, generated by this generator.

	def listOfN (n: Int): Gen[List[A]] = Gen(State.sequence (List.fill (n) (this.sample)))

	// Exercise 4

	def flatMap[B] (f: A => Gen[B]): Gen[B] = {
		def g: (A => State[RNG,B]) = a => f(a).sample
		Gen(this.sample.flatMap(g))
		// the flatMap of State, used above, requires a function (which we called g) that
		// given an A, it outputs a State[RNG,B]. By applying f on a we get a Gen[B] and
		// by applying sample we get the state that is wrapped on that Gen.
		// So then we have the g that we needed to feed to the flatMap of State, we only need
		// to wrap it in a Gen to finally get a Gen[B]
	}
	// def flatMap[B](f: A => State[S, B]): State[S, B]

	// It would be convenient to also have map  (uses flatMap)

	def map[B] (f: A => B): Gen[B] = this.flatMap (a => Gen.unit[B] (f(a)))

	// Exercise 5

	// Use flatMap to implement a more dynamic version of listOfN
	// This version doesn’t generate lists of a fixed size, but uses a generator
	// of integers to pick the size first.
	def listOfN (size: Gen[Int]): Gen[List[A]] = {
		size.flatMap (n => listOfN(n))
	}

	// Exercise 6

	def union (that: Gen[A]): Gen[A] = Gen.boolean2.flatMap (b => if (b) this else that)

	// Exercise 7 continues in the companion object (below)
}

object Gen {

	// A convenience function to convert states (automata) to streams (traces)
	// It would be better to have it in State, but I am not controlling
	// State.scala.

	private  def state2stream[A] (s :State[RNG,A]) (seed :RNG) :Stream[A] =
		s.run(seed) match { case (n,s1) => n #:: state2stream (s) (s1) }

	// A generator for Integer instances

	def anyInteger: Gen[Int] = Gen(State(_.nextInt))

	// Exercise 1

	def choose (start: Int, stopExclusive: Int): Gen[Int] = {
		val range = stopExclusive - start
		Gen(anyInteger.sample.map (x => start + Math.abs(x % range)))
		}

	// Exercise 2

	// FEEBACK:
	// Ex. 2 double
	// I think double meant to be a double between [0,1) not any double number

	def unit[A] (a: =>A): Gen[A] = Gen(State(s => (a,s)))

	def boolean: Gen[Boolean] = Gen(choose(0,2).sample.map(x => x == 1))

	def boolean2: Gen[Boolean] = Gen(anyInteger.sample.map(x => x % 2 == 0))

	def double: Gen[Double] = Gen(anyInteger.sample.map(x => x.toDouble))

	// (Exercise 3 is found in the Gen class above)

}

// This is the Prop type implemented in [Chiusano, Bjarnasson 2015]

object Prop {

	type TestCases = Int
	type SuccessCount = Int
	type FailedCase = String

	// the type of results returned by property testing

	sealed trait Result { def isFalsified: Boolean }
	case object Passed extends Result { def isFalsified = false }
	case class Falsified(failure: FailedCase,
		successes: SuccessCount) extends Result {
			def isFalsified = true
	}
	case object Proved extends Result { def isFalsified = false }

	def forAll[A](as: Gen[A])(f: A => Boolean): Prop = Prop {
		(n,rng) => as.toStream(rng).zip(Stream.from(0)).take(n).map {
			case (a,i) => try {
				if (f(a)) Passed else Falsified(a.toString, i)
			} catch { case e: Exception => Falsified(buildMsg(a, e), i) }
		}.find(_.isFalsified).getOrElse(Passed)
	}

	def buildMsg[A](s: A, e: Exception): String =
		s"test case: $s\n" +
		s"generated an exception: ${e.getMessage}\n" +
		s"stack trace:\n ${e.getStackTrace.mkString("\n")}"
}

import Prop._

case class Prop (run: (TestCases,RNG)=>Result) {
 
	// (Exercise 7)
	// Not sure about our implementation for this one, but what we were able to conjure up.

	// def && (that: Prop): Prop = Prop { 
	//   (tc1, rng1) => { 
	//     val res1 = run(tc1, rng1)
	//     val res2 = that.run(tc1, rng1)
	//     (res1.isFalsified, res2.isFalsified) match {
	//       case (false, false) => Passed
	//       case (_, _) => Falsified("Something failed, you figure it out - use forAll, its easy",0)
	//     }
	//   }
	// }

	// def || (that: Prop): Prop = Prop {
	//    (tc1, rng1) => { 
	//     val res1 = run(tc1, rng1)
	//     val res2 = that.run(tc1, rng1)
	//     (res1.isFalsified, res2.isFalsified) match {
	//       case (true, true) => Passed
	//       case (_, _) => Falsified("Something failed, you figure it out - use forAll, its easy",0)
	//     }
	//   }
	// }

	// FEEDBACK:
	// Ex. 7

	// &&

	// I think I understand the reasoning behind the solution... but I think you did too much
	// aditional work:
	// In the && case the 'trouble' case is when this.run passes because that means we have to

	// run the that Prop, so:
	// case Passed | Proved => that.run ... //this.run passes so we have to check that.run
	// But if this.run fails, we are done :) Now, a test can either pass (Passed | Proved) or fail

	// We took care of the first case so the second we just 'pass it along'
	// case dont_care => dont_care

	// So the structure of the full solution is:
	// case Passed | Proved =>  that.run ..

	// case dont_care => dont_care
	// Can you think how you would do it for the || case?

	def && (that: Prop): Prop = Prop { 
		(tc1, rng1) => { 
			val res1 = run(tc1, rng1)
			val res2 = that.run(tc1, rng1)
			(res1, res2) match {
				case (Passed, Passed) => Passed
				case (fail, Passed) => fail
				case (Passed, fail) => fail
				case (Falsified(fail, succes), Falsified(fail2, succes2)) => Falsified(fail + " " + fail2, succes + succes2)
				case _ => Falsified("Something unexpected happened, as it neiher passed nor failed", 0)
			}
		}
	}

		def || (that: Prop): Prop = Prop {
		 (tc1, rng1) => { 
			val res1 = run(tc1, rng1)
			val res2 = that.run(tc1, rng1)
			(res1, res2) match {
				case (Passed, Passed) => Passed
				case (_, Passed) => Passed
				case (Passed, _) => Passed
				case (Falsified(fail, succes), Falsified(fail2, succes2)) => Falsified(fail + " " + fail2, succes + succes2)
				case _ => Falsified("Something unexpected happened, as it neiher passed nor failed", 0)
			}
		}
	}
}

// vim:cc=80:foldmethod=indent:nofoldenable